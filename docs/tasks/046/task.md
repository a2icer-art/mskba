# task_name
Архитектура контрактов (Contract) и прав по сущностям

# task_status
[0%]

# task_init_description
давай разработаем еще систему контрактов (Contract и ContractType), к которым будут крепиться права на сущности - то есть связь будет не через user_id <> permission_id - а contract_id <> permission_id. у доменной сущности контракт помимо того что контракт необходимо связать с User будут следующие атрибуты: string name, ContractType contract_type (связь с типом контрактов), datetime starts_at ( или предложи свое название ), ends_at (или предложи свое название), status. Также нужно создать сущность ContractType: string name, string/model entity

# task_short_description
Спроектировать систему контрактов (Contract) без ContractType, связать права по сущностям через contract_id и определить статусы/поля.

# full_description

## Контекст и решения
- ContractType не используется: в Contract добавляем `entity_type` + `entity_id`.
- `user_permissions` остаются для базовых (глобальных) прав пользователя.
- Контракты используются для прав, связанных с конкретными сущностями.
- Статусы контракта: `active` / `inactive`.
- Добавить nullable поле `comment`.
- Поле окончания: `ends_at` (nullable). По умолчанию `null`.
- Деактивация: при проверке прав, если `ends_at` в прошлом — контракт считается неактивным
  (и при необходимости переводится в `inactive`).
- У пользователя не может быть нескольких активных контрактов для одной и той же сущности.
- Нужен аудит/история изменений контрактов (минимум кто и когда создал/обновил).
- Итоговая модель прав: `roles + user_permissions` = глобальные права, `contracts` = права по конкретным сущностям.

## План выполнения задачи
1. Описать домен Contracts: сущности, поля, статусы, связи.
2. Спроектировать таблицы: `contracts`, `contract_permissions` (и уникальности).
3. Обновить PermissionChecker для проверки прав через контракты по сущности.
4. Обновить документацию архитектуры и процессов.
